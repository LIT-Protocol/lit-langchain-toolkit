import { CallbackManagerForToolRun } from "@langchain/core/callbacks/manager";
import { StructuredTool, type ToolParams } from "@langchain/core/tools";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import {
  LIT_NETWORK_VALUES,
  LIT_NETWORK,
  LIT_RPC,
} from "@lit-protocol/constants";
import { type LitFields } from "./litToolkit.js";
import { getSessionSigs } from "./utils.js";
import { z } from "zod";
import ethers from "ethers";

/**
 * Tavily search API tool integration.
 *
 * Setup:
 * Install `@langchain/community`. You'll also need an API key set as `TAVILY_API_KEY`.
 *
 * ```bash
 * npm install @langchain/community
 * ```
 *
 * ## [Constructor args](https://api.js.langchain.com/classes/_langchain_community.tools_tavily_search.TavilySearchResults.html#constructor)
 *
 * <details open>
 * <summary><strong>Instantiate</strong></summary>
 *
 * ```typescript
 * import { TavilySearchResults } from "@langchain/community/tools/tavily_search";
 *
 * const tool = new TavilySearchResults({
 *   maxResults: 2,
 *   // ...
 * });
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 *
 * <summary><strong>Invocation</strong></summary>
 *
 * ```typescript
 * await tool.invoke("what is the current weather in sf?");
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 *
 * <summary><strong>Invocation with tool call</strong></summary>
 *
 * ```typescript
 * // This is usually generated by a model, but we'll create a tool call directly for demo purposes.
 * const modelGeneratedToolCall = {
 *   args: {
 *     input: "what is the current weather in sf?",
 *   },
 *   id: "tool_call_id",
 *   name: tool.name,
 *   type: "tool_call",
 * };
 * await tool.invoke(modelGeneratedToolCall);
 * ```
 *
 * ```text
 * ToolMessage {
 *   "content": "...",
 *   "name": "tavily_search_results_json",
 *   "additional_kwargs": {},
 *   "response_metadata": {},
 *   "tool_call_id": "tool_call_id"
 * }
 * ```
 * </details>
 */
export class LitSignerTool extends StructuredTool {
  static lc_name(): string {
    return "Lit";
  }

  description =
    "Can sign a message or transaction using ECDSA secp256k1 with Lit Protocol";

  name = "LitPKPSigner";

  protected litPrivateKey: string;
  protected litNetwork?: LIT_NETWORK_VALUES;
  protected litNodeClient?: LitNodeClient;
  protected signer: ethers.Wallet;
  protected debug: boolean;

  schema = z.object({
    toSign: z.string().describe("The message or transaction to sign"),
    litPkpPublicKey: z
      .string()
      .describe("The public key of the PKP to use for signing"),
  });

  constructor(fields?: LitFields) {
    super(fields);
    this.litPrivateKey = fields?.litPrivateKey!;
    this.litNetwork = fields?.litNetwork || LIT_NETWORK.DatilDev;
    this.litNodeClient = fields?.litNodeClient;
    this.debug = fields?.debug ?? false;
    this.signer = new ethers.Wallet(
      this.litPrivateKey,
      new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)
    );
  }

  protected async _call(
    input: z.infer<typeof this.schema>,
    _runManager?: CallbackManagerForToolRun
  ): Promise<string> {
    try {
      // sign with the PKP
      const toSign = input.toSign;
      // Add 0x prefix if not present
      const prefixedToSign = toSign.startsWith("0x") ? toSign : `0x${toSign}`;

      // Check if it's a 32 byte hex string (64 characters + 0x prefix = 66 chars)
      const is32ByteHex = /^0x[0-9a-fA-F]{64}$/.test(prefixedToSign);

      // If not 32 bytes, hash it
      const finalToSign = is32ByteHex
        ? prefixedToSign
        : ethers.utils.keccak256(ethers.utils.toUtf8Bytes(toSign));

      const sessionSigs = await getSessionSigs(
        this.litNodeClient!,
        this.signer
      );

      const signingResult = await this.litNodeClient!.pkpSign({
        pubKey: input.litPkpPublicKey,
        sessionSigs,
        toSign: ethers.utils.arrayify(finalToSign),
      });

      return JSON.stringify({ signature: signingResult });
    } catch (error) {
      console.error(error);
      return "Error signing message";
    }
  }
}
